<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2D PNG Frame Animation (NFT)</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    .arjs-loader { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); color: white; font-size: 1.1em; z-index: 9999; }
    .tracking-status { position: fixed; top: 10px; left: 10px; padding: 10px;
      background: rgba(0,0,0,0.6); color: white; border-radius: 5px; z-index: 10000; display: none; }
    .debug { position: fixed; bottom: 10px; left: 10px; color: #0f0;
      background: rgba(0,0,0,0.5); padding: 6px 10px; border-radius: 4px; font-size: 12px; z-index: 10000; }
  </style>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>
</head>
<body>
  <div class="arjs-loader">NFT 마커 데이터를 로딩 중입니다…</div>
  <div class="tracking-status" id="trackingStatus">Tracking Lost</div>
  <div class="debug" id="debug">init...</div>

  <a-scene embedded vr-mode-ui="enabled:false" renderer="logarithmicDepthBuffer:true"
    arjs="trackingMethod: best; sourceType: webcam;
          sourceWidth: 1280; sourceHeight: 720;
          displayWidth: 1280; displayHeight: 720;
          detectionMode: mono; debugUIEnabled: false; maxDetectionRate: 30;">
    <a-nft id="nftMarker" type="nft" url="https://leemile.github.io/AR"
      smooth="true" smoothCount="3" smoothTolerance="0.12" smoothThreshold="1">
      <a-plane id="animPlane"
        position="0 0 0.02"
        rotation="0 0 0"
        width="4.5"
        height="4.5"
        visible="false"
        material="color: #000000; transparent:true; opacity:1; side: double; alphaTest:0.01">
      </a-plane>
    </a-nft>
    <a-entity id="cameraRig" camera position="0 0 0"></a-entity>
  </a-scene>

  <script>
    const plane = document.querySelector('#animPlane');
    const marker = document.querySelector('#nftMarker');
    const trackingStatus = document.getElementById('trackingStatus');
    const loaderEl = document.querySelector('.arjs-loader');
    const debugEl = document.getElementById('debug');
    const totalFrames = 23;
    const textures = [];
    let texturesReady = false;
    let planeMesh = null;
    let material = null;
    let currentFrame = 0;
    let rafId = null;
    let playing = false;
    let lostTimer = null;
    let forceShow = false; // f 키 토글

    const setDebug = (msg) => { debugEl.textContent = msg; };

    function waitForPlaneMesh(el) {
      return new Promise((resolve) => {
        const check = () => {
          const mesh = el.getObject3D('mesh');
          if (mesh) return resolve(mesh);
          setTimeout(check, 50);
        };
        el.addEventListener('object3dset', (e) => {
          if (e.detail.type === 'mesh') check();
        });
        el.addEventListener('loaded', check);
        check();
      });
    }

    // 텍스처 로드
    const loader = new THREE.TextureLoader();
    let loadedCount = 0;
    for (let i = 0; i < totalFrames; i++) {
      const num = String(i).padStart(3, '0');
      const filePath = `https://leemile.github.io/frames/frame_${num}.png`;
      textures[i] = loader.load(
        filePath,
        () => {
          if (++loadedCount === totalFrames) {
            texturesReady = true;
            console.log('All textures loaded');
            setDebug('Textures ready');
          }
        },
        undefined,
        (error) => console.error(`Failed to load texture: ${filePath}`, error)
      );
    }

    function animate() {
      if (!playing || !planeMesh || !material) return;
      material.map = textures[currentFrame];
      material.needsUpdate = true;
      setDebug(`Playing frame ${currentFrame}${forceShow ? ' (force)' : ''}`);
      currentFrame = (currentFrame + 1) % totalFrames;
      rafId = requestAnimationFrame(animate);
    }

    function showFirstFrame() {
      if (planeMesh && material && textures[0]) {
        material.map = textures[0];
        material.needsUpdate = true;
      }
    }

    function applyRenderOrder() {
      if (plane.object3D) {
        plane.object3D.renderOrder = 999;
        plane.object3D.traverse(obj => { if (obj.isMesh) obj.renderOrder = 999; });
      }
      if (planeMesh) {
        planeMesh.renderOrder = 999;
      }
    }

    function tryStart() {
      if (!planeMesh || !texturesReady) {
        setDebug('Waiting ready...');
        setTimeout(tryStart, 100);
        return;
      }
      if (!material) {
        material = new THREE.MeshBasicMaterial({
          map: textures[0],
          transparent: true,
          side: THREE.DoubleSide,
          alphaTest: 0.01,
          depthTest: false,
          depthWrite: false
        });
        planeMesh.material = material;
        applyRenderOrder();
      }
      showFirstFrame();
      plane.setAttribute('visible', true);
      trackingStatus.style.display = forceShow ? 'none' : 'none';
      if (playing) return;
      playing = true;
      console.log('Animation start');
      setDebug(`Playing frame ${currentFrame}${forceShow ? ' (force)' : ''}`);
      animate();
    }

    function stop() {
      if (forceShow) return; // 강제 표시 모드면 멈추지 않음
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      playing = false;
      currentFrame = 0;
      showFirstFrame();
      plane.setAttribute('visible', false);
      trackingStatus.style.display = 'block';
      console.log('Animation stop');
      setDebug('Stopped');
    }

    marker.addEventListener('markerFound', () => {
      console.log('Marker Found');
      setDebug('Found');
      if (lostTimer) { clearTimeout(lostTimer); lostTimer = null; }
      tryStart();
    });

    marker.addEventListener('markerLost', () => {
      console.log('Marker Lost (debounce start)');
      setDebug('Lost? wait');
      if (lostTimer) clearTimeout(lostTimer);
      lostTimer = setTimeout(() => {
        console.log('Marker Lost (confirmed)');
        stop();
      }, 2000);
    });

    waitForPlaneMesh(plane).then((mesh) => {
      console.log('Plane mesh ready');
      planeMesh = mesh;
      setDebug('Mesh ready');
      applyRenderOrder();
    });

    document.querySelector('a-scene').addEventListener('loaded', () => {
      loaderEl.style.display = 'none';
    });

    // f 키로 강제 표시/해제 (마커 무시)
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'f') {
        forceShow = !forceShow;
        if (forceShow) {
          setDebug('Force show ON');
          // 카메라 앞에 강제 위치
          plane.object3D.position.set(0, 0, -3);
          plane.object3D.rotation.set(0, 0, 0);
          plane.setAttribute('visible', true);
          tryStart();
        } else {
          setDebug('Force show OFF');
          stop();
        }
      }
    });
  </script>
</body>
</html>
