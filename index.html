<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>AR.js THREE - NFT PNG Animation</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
    #video {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
      z-index: 1;
      background: #000;
    }
    canvas { position: fixed !important; inset: 0; z-index: 2; }
    #hud {
      position: fixed; left: 10px; top: 10px; z-index: 9999;
      font: 12px/1.35 monospace; color:#0f0;
      background: rgba(0,0,0,.6); padding: 10px; border-radius: 8px; white-space: pre;
      max-width: 94vw;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ar-js-org/ar.js@3.4.7/three.js/build/ar-threex.js"></script>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <div id="hud">boot...</div>

  <script>
    const hudEl = document.getElementById('hud');
    const videoEl = document.getElementById('video');

    const NFT_BASE = 'https://leemile.github.io/AR';
    const CAMERA_PARA = 'https://leemile.github.io/data/camera_para.dat';

    const TOTAL = 22;
    const FPS = 12;
    const FRAME_MS = 1000 / FPS;
    const FRAME_URL = (i) => `https://leemile.github.io/frames/frame_${String(i).padStart(3,'0')}.png`;

    let renderer, scene, camera;
    let arContext, markerRoot;

    let material;
    const textures = new Array(TOTAL);
    let loaded = 0;

    let playing = false;
    let frame = 0;
    let lastSwap = 0;

    function hud(extra='') {
      hudEl.textContent =
`video: ${videoEl.readyState} (${videoEl.videoWidth}x${videoEl.videoHeight})
textures: ${loaded}/${TOTAL}
markerVisible: ${markerRoot ? markerRoot.visible : false}
playing: ${playing}
frame: ${frame}
${extra}`;
    }

    async function startVideo() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' },
        audio: false
      });
      videoEl.srcObject = stream;
      await videoEl.play();
    }

    function initThree() {
      scene = new THREE.Scene();
      camera = new THREE.Camera();
      scene.add(camera);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setClearColor(new THREE.Color('black'), 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function loadTextures() {
      const tl = new THREE.TextureLoader();
      tl.setCrossOrigin('anonymous');

      for (let i = 0; i < TOTAL; i++) {
        tl.load(FRAME_URL(i), (tex) => {
          textures[i] = tex;
          loaded++;
        }, undefined, (err) => console.error('texture load fail', i, err));
      }
    }

    function initAR() {
      arContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: CAMERA_PARA,
        detectionMode: 'mono'
      });

      arContext.init(() => {
        camera.projectionMatrix.copy(arContext.getProjectionMatrix());
      });

      markerRoot = new THREE.Group();
      scene.add(markerRoot);

      new THREEx.ArMarkerControls(arContext, markerRoot, {
        type: 'nft',
        descriptorsUrl: NFT_BASE
      });

      material = new THREE.MeshBasicMaterial({
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false
      });

      const plane = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), material);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = 0.01;
      markerRoot.add(plane);
    }

    function setFrame(i) {
      const t = textures[i];
      if (!t) return;
      material.map = t;
      material.needsUpdate = true;
    }

    function startAnim() {
      if (playing) return;
      if (loaded !== TOTAL) return;
      playing = true;
      frame = 0;
      lastSwap = 0;
      setFrame(0);
    }

    function stopAnim() {
      playing = false;
      material.map = null;
      material.needsUpdate = true;
    }

    function loop(now) {
      requestAnimationFrame(loop);

      if (arContext && videoEl.readyState >= 2) {
        arContext.update(videoEl);
      }

      const visible = !!(markerRoot && markerRoot.visible);

      if (visible) startAnim();
      else stopAnim();

      if (playing && visible) {
        if (now - lastSwap >= FRAME_MS) {
          setFrame(frame);
          frame = (frame + 1) % TOTAL;
          lastSwap = now;
        }
      }

      renderer.render(scene, camera);
      hud();
    }

    (async () => {
      try {
        hud('starting...');
        await startVideo();
        initThree();
        loadTextures();
        initAR();
        loop(0);
      } catch (e) {
        console.error(e);
        hud('ERROR: ' + (e && e.message ? e.message : e));
      }
    })();
  </script>
</body>
</html>
