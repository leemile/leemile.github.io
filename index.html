<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2D PNG Frame Animation (NFT)</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    .arjs-loader {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); color: white; font-size: 1.1em;
      z-index: 9999;
    }
    .tracking-status {
      position: fixed; top: 10px; left: 10px;
      padding: 10px; background: rgba(0,0,0,0.6); color: white;
      border-radius: 5px; z-index: 10000; display: none;
    }
    .debug {
      position: fixed; bottom: 10px; left: 10px; color: #0f0;
      background: rgba(0,0,0,0.5); padding: 6px 10px; border-radius: 4px;
      font-size: 12px; z-index: 10000;
    }
  </style>
  <!-- A-Frame 먼저 -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- AR.js NFT (A-Frame 이후) -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>
</head>
<body>
  <div class="arjs-loader">NFT 마커 데이터를 로딩 중입니다…</div>
  <div class="tracking-status" id="trackingStatus">Tracking Lost</div>
  <div class="debug" id="debug">init...</div>

  <a-scene
    embedded
    vr-mode-ui="enabled:false"
    renderer="logarithmicDepthBuffer:true"
    arjs="trackingMethod: best;
          sourceType: webcam;
          sourceWidth: 1280; sourceHeight: 720;
          displayWidth: 1280; displayHeight: 720;
          detectionMode: mono;
          debugUIEnabled: false;
          maxDetectionRate: 30;">
    <a-nft
      id="nftMarker"
      type="nft"
      url="https://leemile.github.io/AR"
      smooth="true"
      smoothCount="3"
      smoothTolerance="0.12"
      smoothThreshold="1">
      <a-plane
        id="animPlane"
        position="0 0 0.02"
        rotation="0 0 0"
        width="4"
        height="4"
        visible="false"
        material="color: #000000; transparent:true; opacity:1; side: double; alphaTest:0.01">
      </a-plane>
    </a-nft>
    <a-entity camera></a-entity>
  </a-scene>

  <script>
    const plane = document.querySelector('#animPlane');
    const marker = document.querySelector('#nftMarker');
    const trackingStatus = document.getElementById('trackingStatus');
    const loaderEl = document.querySelector('.arjs-loader');
    const debugEl = document.getElementById('debug');

    const totalFrames = 23;
    const textures = [];
    let texturesReady = false;
    let planeMesh = null;
    let material = null;
    let currentFrame = 0;
    let rafId = null;
    let playing = false;
    let lostTimer = null;

    const setDebug = (msg) => { debugEl.textContent = msg; };

    function waitForPlaneMesh(el) {
      return new Promise((resolve) => {
        const check = () => {
          const mesh = el.getObject3D('mesh');
          if (mesh) return resolve(mesh);
          setTimeout(check, 50);
        };
        el.addEventListener('object3dset', (e) => {
          if (e.detail.type === 'mesh') check();
        });
        el.addEventListener('loaded', check);
        check();
      });
    }

    // 텍스처 로드 (절대경로)
    const loader = new THREE.TextureLoader();
    let loadedCount = 0;
    for (let i = 0; i < totalFrames; i++) {
      const num = String(i).padStart(3, '0');
      const filePath = `https://leemile.github.io/frames/frame_${num}.png`;
      textures[i] = loader.load(
        filePath,
        () => {
          if (++loadedCount === totalFrames) {
            texturesReady = true;
            console.log('All textures loaded');
            setDebug('Textures ready');
          }
        },
        undefined,
        (error) => console.error(`Failed to load texture: ${filePath}`, error)
      );
    }

    function animate() {
      if (!playing || !planeMesh || !material) return;
      material.map = textures[currentFrame];
      material.needsUpdate = true;
      currentFrame = (currentFrame + 1) % totalFrames;
      rafId = requestAnimationFrame(animate);
    }

    function showFirstFrame() {
      if (planeMesh && material && textures[0]) {
        material.map = textures[0];
        material.needsUpdate = true;
      }
    }

    function tryStart() {
      if (!planeMesh || !texturesReady) {
        setDebug('Waiting ready...');
        setTimeout(tryStart, 100);
        return;
      }
      if (!material) {
        material = new THREE.MeshBasicMaterial({
          map: textures[0],
          transparent: true,
          side: THREE.DoubleSide,
          alphaTest: 0.01,
          depthTest: false,
          depthWrite: false
        });
        planeMesh.material = material;
        // 항상 위에 그리기
        plane.object3D.renderOrder = 999;
      }
      showFirstFrame();
      plane.setAttribute('visible', true);
      trackingStatus.style.display = 'none';
      if (playing) return;
      playing = true;
      console.log('Animation start');
      setDebug('Playing');
      animate();
    }

    function stop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      playing = false;
      currentFrame = 0;
      showFirstFrame(); // 기본 프레임 유지
      plane.setAttribute('visible', false);
      trackingStatus.style.display = 'block';
      console.log('Animation stop');
      setDebug('Stopped');
    }

    marker.addEventListener('markerFound', () => {
      console.log('Marker Found');
      setDebug('Found');
      if (lostTimer) { clearTimeout(lostTimer); lostTimer = null; }
      tryStart();
    });

    // Lost 시 1500ms 지연 후 진짜 Lost로 처리
    marker.addEventListener('markerLost', () => {
      console.log('Marker Lost (debounce start)');
      setDebug('Lost? wait');
      if (lostTimer) clearTimeout(lostTimer);
      lostTimer = setTimeout(() => {
        console.log('Marker Lost (confirmed)');
        stop();
      }, 1500);
    });

    waitForPlaneMesh(plane).then((mesh) => {
      console.log('Plane mesh ready');
      planeMesh = mesh;
      setDebug('Mesh ready');
    });

    document.querySelector('a-scene').addEventListener('loaded', () => {
      loaderEl.style.display = 'none';
    });
  </script>
</body>
</html>
